<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Words3D</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			} 
			body {
				color: #000000;
				font-family: Monospace;
				font-size: 14px;
				text-align: center;
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions {
				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;
			
				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;
				
				color: #ffffff;
				text-align: center;
				vertical-align: center;			
	
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div id="blocker">
			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Up, Ctrl = Down, MOUSE = Look around)
			</div>
		</div>

		<div id="container"></div>
		<div id="info"><a href="https://docs.google.com/document/d/e/2PACX-1vS6udanhjSdhS8J_GsUss8-OKq1OAdoE1MPMZ2VTvbtMmXL1o2hHHP55DFK51S-jCIixoBdUYyueXOb/pub" target="_blank" rel="noopener">Project List</a> - Word 3D<br />(left click: place, right click: remove)</div>

		<script src="src/js/three.min.js"></script>
		<script src="src/js/controls/PointerLockControls.js"></script>		
		

		<!-- TODO: write custom controls -->
		<!--<script src="src/js/controls/FirstPersonControls.js"></script> -->

		<script src="src/js/Detector.js"></script>

		<script>
			if(!Detector.webgl) {
				Detector.addGetWebGLMessage();
				document.getElementByID('container').innerHTML = "";
			}
			var container;
			var camera, controls, scene, renderer;
			var cube;
			var mesh;
			var mouse, raycaster, isShiftDown = false;

			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;
		
			var clock = new THREE.Clock();
		
			var objects = [];

			var boardWidth = 15, boardDepth = 15, boardHeight = 15;
		
			var blocker = document.getElementById('blocker');
			var instructions = document.getElementById('instructions');
		
			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if(havePointerLock) {
				var element = document.body;

				var pointerlockchange = function(event) {
					if(document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
						controlsEnabled = true;
						controls.enabled = true;
						
						blocker.style.display = 'none';
					} else {
						controls.enabled = false;
						
						blocker.style.display = 'block'
						instructions.style.display = '';
					}
				};

				var pointerlockerror = function(event) {
					instructions.style.display = '';
				};

				//Hook pointer lock state change events
				document.addEventListener('pointerlockchange', pointerlockchange, false);
				document.addEventListener('mozpointerlockchange', pointerlockchange, false);
				document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

				document.addEventListener('pointerlockerror', pointerlockerror, false);
				document.addEventListener('mozpointerlockerror', pointerlockerror, false);
				document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
				
				instructions.addEventListener('click', function( event ) {

					instructions.style.display = 'none';

					//ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitrequestpointerlock;
					element.requestPointerLock();
				}, false);
			
			} else {
				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
			}

			init();
			animate();

			function init() {
				container = document.getElementById('container');
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
				//camera.position.y = getY(7, 7) * 100 + 100;
				
				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xf5f5f5);
				
				//Roll-over helper
				var rollOverGeo = new THREE.BoxGeometry(64, 64, 64);
				rollOverMaterial = new THREE.MeshBasicMaterial( {color: 0x00ff00, opacity: 0.5, transparent: true});
				rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
				scene.add(rollOverMesh);

				cubePosMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
				cubePosMesh.position.y = cubePosMesh.position.y + 64;
				scene.add(cubePosMesh);	

				//cubes
				var texture = new THREE.TextureLoader().load('assets/a.png');
				texture.magFilter = THREE.LinearMipMapLinearFilter;
				texture.minFilter = THREE.LinearMipMapLinearFilter;

				cubeGeo = new THREE.BoxGeometry(64, 64, 64);				
				cubeMaterial = new THREE.MeshLambertMaterial({map: texture});
				
				//grids
				var gridHelper = new THREE.GridHelper(960, 15);
				scene.add(gridHelper);

				//raycasting
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				
				var geometry = new THREE.PlaneBufferGeometry(960, 960);
				geometry.rotateX( - Math.PI / 2);

				plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial( {visible: false }));
				scene.add(plane);
				
				objects.push(plane);

				controls = new THREE.PointerLockControls(camera);
				
				controls.movementSpeed = 1000;
				controls.lookSpeed = 0.002;
				controls.enabled = true;
				scene.add(controls.getObject());
				
				/*
				camera.position.x = objects[0].position.x + 100;
				camera.position.y = objects[0].position.y + 100;
				camera.position.z = objects[0].position.z + 100;
				*/

				/*
				controls.lookVertical = true;
				*/

				//Lights
				var ambientLight = new THREE.AmbientLight(0x606060);
				scene.add(ambientLight);

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
		
				document.addEventListener('mouseDown', onDocumentMouseDown, false);
				document.addEventListener('shiftDown', onDocumentKeyDown, false);
				document.addEventListener('shiftUp', onDocumentKeyUp, false);
				
				
				window.addEventListener('resize', onWindowResize, false);
			}

			function getY(x, z) {
				return 10;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			
			function onDocumentMouseDown(event) {
				event.preventDefault();
				mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
				
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.instersectObjects(objects);
				if(intersects.length > 0) {
					var intersect = intersects[0];
	
					//cube deletion
					if(isShiftDown) {
						if(intersect.object != plane) {
							scene.remove(intersect.object);
							objects.splice(objects.indexOf(intersect.object), 1);
						}
					} else { //create cube
						var voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
						voxel.position.copy(intersect.point).add(intersect.face.normal);
						voxel.position.divideScalar(64).floor().multiplyScalar(64).addScalar(32);
						scene.add(voxel);
						objects.push(voxel);
					}
				}
			}

			function onDocumentKeyDown(event) {

				switch(event.keyCode) {
					case 16: isShiftDown = true;
						break;
				}
			}

			function onDocumentKeyUp(event) {
				switch(event.keyCode) {
					case 16: isShiftDown = false;
						break;
				}
			}
			
			function animate() {
				requestAnimationFrame(animate);
				
				render();
			}

			function render() {
				controls.update(clock.getDelta());
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>



